//! Implements the Rust codegen pass.

use anyhow::Context as _;
use std::{
    collections::{BTreeMap, HashMap, HashSet},
    io::Write,
    path::{Path, PathBuf},
};

use crate::{
    codegen::{StringExt as _, AUTOGEN_WARNING},
    ArrowRegistry, CodeGenerator, Docs, ElementType, LazyDatatype, LazyField, Object, ObjectField,
    ObjectKind, Objects, Type, ATTR_RERUN_COMPONENT_OPTIONAL, ATTR_RERUN_COMPONENT_RECOMMENDED,
    ATTR_RERUN_COMPONENT_REQUIRED, ATTR_RUST_DERIVE, ATTR_RUST_REPR, ATTR_RUST_TUPLE_STRUCT,
};

// ---

// TODO: just remove vecs everywhere and always use buffers instead? actually, just do that for
// actual Fbs::Vector types

// TODO: need an issue to deserialize into references (or `Buffer`s)?
// TODO: outright ban the use of implicit types (_) in autogenerated code?
// TODO: okay maybe it is time to actually use quote!{}
// TODO: differentiating obj field vs. arrow field in becoming quite hard... need a naming pass
// TODO: at soem point a string joiner helper would be too much eh

pub struct RustCodeGenerator {
    crate_path: PathBuf,
}

impl RustCodeGenerator {
    pub fn new(crate_path: impl Into<PathBuf>) -> Self {
        Self {
            crate_path: crate_path.into(),
        }
    }
}

impl CodeGenerator for RustCodeGenerator {
    fn quote(&mut self, objects: &Objects, arrow_registry: &ArrowRegistry) -> Vec<PathBuf> {
        let mut filepaths = Vec::new();

        let datatypes_path = self.crate_path.join("src/datatypes");
        std::fs::create_dir_all(&datatypes_path)
            .with_context(|| format!("{datatypes_path:?}"))
            .unwrap();
        filepaths.extend(quote_objects(
            datatypes_path,
            arrow_registry,
            objects,
            &objects.ordered_objects(ObjectKind::Datatype.into()),
        ));

        let components_path = self.crate_path.join("src/components");
        std::fs::create_dir_all(&components_path)
            .with_context(|| format!("{components_path:?}"))
            .unwrap();
        filepaths.extend(quote_objects(
            components_path,
            arrow_registry,
            objects,
            &objects.ordered_objects(ObjectKind::Component.into()),
        ));

        let archetypes_path = self.crate_path.join("src/archetypes");
        std::fs::create_dir_all(&archetypes_path)
            .with_context(|| format!("{archetypes_path:?}"))
            .unwrap();
        filepaths.extend(quote_objects(
            archetypes_path,
            arrow_registry,
            objects,
            &objects.ordered_objects(ObjectKind::Archetype.into()),
        ));

        filepaths
    }
}

// --- File management ---

fn quote_objects(
    out_path: impl AsRef<Path>,
    arrow_registry: &ArrowRegistry,
    objects: &Objects,
    objs: &[&Object],
) -> Vec<PathBuf> {
    let out_path = out_path.as_ref();

    let mut filepaths = Vec::new();

    let mut files = HashMap::<PathBuf, Vec<QuotedObject>>::new();
    for obj in objs {
        let obj = if obj.is_struct() {
            QuotedObject::from_struct(arrow_registry, objects, obj)
        } else {
            QuotedObject::from_union(arrow_registry, objects, obj)
        };

        let filepath = out_path.join(obj.filepath.file_name().unwrap());
        files.entry(filepath.clone()).or_default().push(obj);
    }

    // (module_name, [object_name])
    let mut mods = HashMap::<String, Vec<String>>::new();

    // src/{datatypes|components|archetypes}/{xxx}.rs
    for (filepath, objs) in files {
        // NOTE: Isolating the file stem only works because we're handling datatypes, components
        // and archetypes separately (and even then it's a bit shady, eh).
        let names = objs.iter().map(|obj| obj.name.clone()).collect::<Vec<_>>();
        mods.entry(filepath.file_stem().unwrap().to_string_lossy().to_string())
            .or_default()
            .extend(names);

        filepaths.push(filepath.clone());
        let mut file = std::fs::File::create(&filepath)
            .with_context(|| format!("{filepath:?}"))
            .unwrap();

        let mut code = String::new();
        code.push_text(format!("// {AUTOGEN_WARNING}"), 2, 0);

        for obj in objs {
            code.push_text(&obj.code, 1, 0);
        }
        file.write_all(code.as_bytes())
            .with_context(|| format!("{filepath:?}"))
            .unwrap();
    }

    // src/{datatypes|components|archetypes}/mod.rs
    {
        let path = out_path.join("mod.rs");

        let mut code = String::new();

        code.push_text(format!("// {AUTOGEN_WARNING}"), 2, 0);

        for module in mods.keys() {
            code.push_text(format!("mod {module};"), 1, 0);

            // Detect if someone manually created an extension file, and automatically
            // import it if so.
            let mut ext_path = out_path.join(format!("{module}_ext"));
            ext_path.set_extension("rs");
            if ext_path.exists() {
                code.push_text(format!("mod {module}_ext;"), 1, 0);
            }
        }

        code += "\n\n";

        for (module, names) in &mods {
            let names = names.join(", ");
            code.push_text(format!("pub use self::{module}::{{{names}}};"), 1, 0);
        }

        filepaths.push(path.clone());
        std::fs::write(&path, code)
            .with_context(|| format!("{path:?}"))
            .unwrap();
    }

    filepaths
}

// --- Codegen core loop ---

#[derive(Debug, Clone)]
struct QuotedObject {
    filepath: PathBuf,
    name: String,
    code: String,
}

impl QuotedObject {
    fn from_struct(arrow_registry: &ArrowRegistry, objects: &Objects, obj: &Object) -> Self {
        assert!(obj.is_struct());

        let Object {
            filepath,
            fqname: _,
            pkg_name: _,
            name,
            docs,
            kind,
            attrs: _,
            fields,
            specifics: _,
            datatype: _,
        } = obj;

        let mut code = String::new();

        code.push_text(&quote_doc_from_docs(docs), 0, 0);

        if let Some(clause) = quote_derive_clause_from_obj(obj) {
            code.push_text(&clause, 1, 0);
        }
        if let Some(clause) = quote_repr_clause_from_obj(obj) {
            code.push_text(&clause, 1, 0);
        }

        let is_tuple_struct = is_tuple_struct_from_obj(obj);

        if is_tuple_struct {
            code.push_text(&format!("pub struct {name}("), 0, 0);
        } else {
            code.push_text(&format!("pub struct {name} {{"), 1, 0);
        }

        for field in fields {
            let ObjectField {
                filepath: _,
                pkg_name: _,
                fqname: _,
                name,
                docs,
                typ: _,
                attrs: _,
                required,
                // TODO(#2366): support for deprecation notices
                deprecated: _,
                datatype: _,
            } = field;

            code.push_text(&quote_doc_from_docs(docs), 0, 0);

            let (typ, _) = quote_field_type_from_field(field, false);
            let typ = if *required {
                typ
            } else {
                format!("Option<{typ}>")
            };

            if is_tuple_struct {
                code.push_text(&format!("pub {typ}"), 0, 0);
            } else {
                code.push_text(&format!("pub {name}: {typ},"), 2, 0);
            }
        }

        if is_tuple_struct {
            code += ");\n\n";
        } else {
            code += "}\n\n";
        }

        code.push_text(
            &quote_trait_impls_from_obj(arrow_registry, objects, obj),
            1,
            0,
        );

        if kind == &ObjectKind::Archetype {
            code.push_text(&quote_builder_from_obj(obj), 0, 0);
        }

        let mut filepath = PathBuf::from(filepath);
        filepath.set_extension("rs");

        Self {
            filepath,
            name: obj.name.clone(),
            code,
        }
    }

    fn from_union(arrow_registry: &ArrowRegistry, objects: &Objects, obj: &Object) -> Self {
        assert!(!obj.is_struct());

        let Object {
            filepath,
            fqname: _,
            pkg_name: _,
            name,
            docs,
            kind: _,
            attrs: _,
            fields,
            specifics: _,
            datatype: _,
        } = obj;

        let mut code = String::new();

        code.push_text(&quote_doc_from_docs(docs), 0, 0);

        if let Some(clause) = quote_derive_clause_from_obj(obj) {
            code.push_text(&clause, 1, 0);
        }
        if let Some(clause) = quote_repr_clause_from_obj(obj) {
            code.push_text(&clause, 1, 0);
        }

        code.push_text(&format!("pub enum {name} {{"), 1, 0);

        for field in fields {
            let ObjectField {
                filepath: _,
                fqname: _,
                pkg_name: _,
                name,
                docs,
                typ: _,
                attrs: _,
                required: _,
                deprecated: _,
                datatype: _,
            } = field;

            code.push_text(&quote_doc_from_docs(docs), 0, 0);

            let (typ, _) = quote_field_type_from_field(field, false);

            code.push_text(&format!("{name}({typ}),"), 2, 0);
        }

        code += "}\n\n";

        code.push_text(
            &quote_trait_impls_from_obj(arrow_registry, objects, obj),
            1,
            0,
        );

        let mut filepath = PathBuf::from(filepath);
        filepath.set_extension("rs");

        Self {
            filepath,
            name: obj.name.clone(),
            code,
        }
    }
}

// --- Code generators ---

fn quote_doc_from_docs(docs: &Docs) -> String {
    let lines = crate::codegen::quote_doc_from_docs(docs, &["rs", "rust"]);
    let lines = lines
        .into_iter()
        .map(|line| format!("/// {line}"))
        .collect::<Vec<_>>();

    let mut doc = lines.join("\n");
    doc.push('\n');
    doc
}

/// Returns type name as string and whether it was force unwrapped.
///
/// Specifying `unwrap = true` will unwrap the final type before returning it, e.g. `Vec<String>`
/// becomes just `String`.
/// The returned boolean indicates whether there was anything to unwrap at all.
fn quote_field_type_from_field(field: &ObjectField, unwrap: bool) -> (String, bool) {
    let mut unwrapped = false;
    let typ = &field.typ;
    let typ = match typ {
        Type::UInt8 => "u8".to_owned(),
        Type::UInt16 => "u16".to_owned(),
        Type::UInt32 => "u32".to_owned(),
        Type::UInt64 => "u64".to_owned(),
        Type::Int8 => "i8".to_owned(),
        Type::Int16 => "i16".to_owned(),
        Type::Int32 => "i32".to_owned(),
        Type::Int64 => "i64".to_owned(),
        Type::Bool => "bool".to_owned(),
        Type::Float16 => unimplemented!("{typ:#?}"), // NOLINT
        Type::Float32 => "f32".to_owned(),
        Type::Float64 => "f64".to_owned(),
        Type::String => "String".to_owned(),
        Type::Array { elem_type, length } => {
            let typ = quote_type_from_element_type(elem_type);
            if unwrap {
                unwrapped = true;
                typ
            } else {
                format!("[{typ}; {length}]")
            }
        }
        Type::Vector { elem_type } => {
            let typ = quote_type_from_element_type(elem_type);
            if unwrap {
                unwrapped = true;
                typ
            } else {
                format!("Vec<{typ}>")
            }
        }
        Type::Object(fqname) => fqname.replace('.', "::").replace("rerun", "crate"),
    };

    (typ, unwrapped)
}

fn quote_type_from_element_type(typ: &ElementType) -> String {
    match typ {
        ElementType::UInt8 => "u8".to_owned(),
        ElementType::UInt16 => "u16".to_owned(),
        ElementType::UInt32 => "u32".to_owned(),
        ElementType::UInt64 => "u64".to_owned(),
        ElementType::Int8 => "i8".to_owned(),
        ElementType::Int16 => "i16".to_owned(),
        ElementType::Int32 => "i32".to_owned(),
        ElementType::Int64 => "i64".to_owned(),
        ElementType::Bool => "bool".to_owned(),
        ElementType::Float16 => unimplemented!("{typ:#?}"), // NOLINT
        ElementType::Float32 => "f32".to_owned(),
        ElementType::Float64 => "f64".to_owned(),
        ElementType::String => "String".to_owned(),
        ElementType::Object(fqname) => fqname.replace('.', "::").replace("rerun", "crate"),
    }
}

fn quote_derive_clause_from_obj(obj: &Object) -> Option<String> {
    obj.try_get_attr::<String>(ATTR_RUST_DERIVE)
        .map(|what| format!("#[derive({what})]"))
}

fn quote_repr_clause_from_obj(obj: &Object) -> Option<String> {
    obj.try_get_attr::<String>(ATTR_RUST_REPR)
        .map(|what| format!("#[repr({what})]"))
}

fn is_tuple_struct_from_obj(obj: &Object) -> bool {
    obj.is_struct()
        && obj.fields.len() == 1
        && obj.try_get_attr::<String>(ATTR_RUST_TUPLE_STRUCT).is_some()
}

// TODO:
// - put extensions everywhere when dumping types
// - remove extensions everywhere when dumping data?

fn quote_trait_impls_from_obj(
    arrow_registry: &ArrowRegistry,
    objects: &Objects,
    obj: &Object,
) -> String {
    let Object {
        filepath: _,
        fqname,
        pkg_name: _,
        name,
        docs: _,
        kind,
        attrs: _,
        fields: _,
        specifics: _,
        datatype: _,
    } = obj;

    match kind {
        ObjectKind::Datatype => {
            let datatype = quote_arrow_datatype(&arrow_registry.get(fqname));
            let serializer = quote_arrow_serializer_from_obj(&arrow_registry, objects, obj, &[]);
            // let deserializer = quote_arrow_deserializer_from_obj_legacy(&arrow_registry, obj);
            let deserializer =
                quote_arrow_deserializer_from_obj(&arrow_registry, objects, obj, &[]);
            format!(
                r#"
                // TODO: explanations

                impl<'a> From<{name}> for ::std::borrow::Cow<'a, {name}> {{
                    fn from(value: {name}) -> Self {{
                        std::borrow::Cow::Owned(value)
                    }}
                }}

                impl<'a> From<&'a {name}> for ::std::borrow::Cow<'a, {name}> {{
                    fn from(value: &'a {name}) -> Self {{
                        std::borrow::Cow::Borrowed(value)
                    }}
                }}

                impl crate::Datatype for {name} {{
                    fn name() -> crate::DatatypeName {{
                        crate::DatatypeName::Borrowed({fqname:?})
                    }}

                    #[allow(clippy::wildcard_imports)]
                    fn to_arrow_datatype() -> arrow2::datatypes::DataType {{
                        use ::arrow2::datatypes::*;
                        {datatype}
                    }}

                    #[allow(clippy::wildcard_imports)]
                    fn to_arrow<'a>(data: impl IntoIterator<Item = impl Into<::std::borrow::Cow<'a, Self>>>) -> ::re_log_types::DataCell
                    where
                        Self: Clone + 'a
                    {{
                        use ::arrow2::datatypes::*;
                        use ::arrow2::array::*;
                        // TOOD: need attr_rerun_legacy_name?
                        ::re_log_types::DataCell::from_arrow("{fqname}".into(), {{ {serializer} }})
                    }}

                    fn from_arrow(cell: &::re_log_types::DataCell) -> Vec<Self>
                    where
                        Self: Sized
                    {{
                        use ::arrow2::datatypes::*;
                        use ::arrow2::array::*;
                        {deserializer}
                    }}
                }}
                "#
            )
        }
        ObjectKind::Component => {
            let datatype = quote_arrow_datatype(&arrow_registry.get(fqname));
            let serializer = quote_arrow_serializer_from_obj(&arrow_registry, objects, obj, &[]);
            let deserializer =
                quote_arrow_deserializer_from_obj(&arrow_registry, objects, obj, &[]);
            // let serializer = "todo!()";
            // let deserializer = "todo!()";
            format!(
                r#"
                impl<'a> From<{name}> for ::std::borrow::Cow<'a, {name}> {{
                    fn from(value: {name}) -> Self {{
                        std::borrow::Cow::Owned(value)
                    }}
                }}

                impl<'a> From<&'a {name}> for ::std::borrow::Cow<'a, {name}> {{
                    fn from(value: &'a {name}) -> Self {{
                        std::borrow::Cow::Borrowed(value)
                    }}
                }}

                impl crate::Component for {name} {{
                    fn name() -> crate::ComponentName {{
                        crate::ComponentName::Borrowed({fqname:?})
                    }}

                    #[allow(clippy::wildcard_imports)]
                    fn to_arrow_datatype() -> arrow2::datatypes::DataType {{
                        use ::arrow2::datatypes::*;
                        {datatype}
                    }}

                    #[allow(clippy::wildcard_imports)]
                    fn to_arrow<'a>(data: impl IntoIterator<Item = impl Into<::std::borrow::Cow<'a, Self>>>) -> ::re_log_types::DataCell
                    where
                        Self: Clone + 'a
                    {{
                        use ::arrow2::datatypes::*;
                        use ::arrow2::array::*;
                        // TOOD: need attr_rerun_legacy_name?
                        ::re_log_types::DataCell::from_arrow("{fqname}".into(), {{ {serializer} }})
                    }}

                    fn from_arrow(cell: &::re_log_types::DataCell) -> Vec<Self>
                    where
                        Self: Sized
                    {{
                        use ::arrow2::datatypes::*;
                        use ::arrow2::array::*;
                        {deserializer}
                    }}
                }}
                "#
            )
        }
        ObjectKind::Archetype => {
            fn compute_components(obj: &Object, attr: &'static str) -> (usize, String) {
                let components = iter_archetype_components(obj, attr).collect::<Vec<_>>();

                let num_components = components.len();
                let components = components
                    .into_iter()
                    .map(|fqname| format!("crate::ComponentName::Borrowed({fqname:?})"))
                    .collect::<Vec<_>>()
                    .join(", ");

                (num_components, components)
            }

            let (num_required, required) = compute_components(obj, ATTR_RERUN_COMPONENT_REQUIRED);
            let (num_recommended, recommended) =
                compute_components(obj, ATTR_RERUN_COMPONENT_RECOMMENDED);
            let (num_optional, optional) = compute_components(obj, ATTR_RERUN_COMPONENT_OPTIONAL);

            let num_all = num_required + num_recommended + num_optional;
            let all = [required.as_str(), recommended.as_str(), optional.as_str()]
                .as_slice()
                .join(", ");

            let all_datatypes = {
                let required = iter_archetype_components(obj, ATTR_RERUN_COMPONENT_REQUIRED);
                let recommended = iter_archetype_components(obj, ATTR_RERUN_COMPONENT_RECOMMENDED);
                let optional = iter_archetype_components(obj, ATTR_RERUN_COMPONENT_OPTIONAL);

                required
                    .chain(recommended)
                    .chain(optional)
                    .map(|fqname| {
                        let name = fqname
                            .rsplit_once('.')
                            .map_or(fqname.clone(), |(_, name)| name.to_owned());
                        format!("crate::components::{name}::to_arrow_datatype()")
                    })
                    .collect::<Vec<_>>()
                    .join(", ")
            };

            let all_serializers = {
                obj.fields
                    .iter()
                    .map(|field| {
                        let accessor = format!("self.{}", field.name);

                        let is_plural = field.typ.is_plural();
                        let is_optional = !field.required;

                        // NOTE: unwrapping has to be safe since the field has to point to a
                        // component.
                        let component = field.typ.fqname().unwrap();
                        let component = component.rsplit_once('.').unwrap().1;
                        let component = format!("crate::components::{component}");

                        match (is_plural, is_optional) {
                            (true, true) => {
                                format!("crate::to_arrow_opt::<{component}>({accessor}.as_ref())")
                            }
                            (true, false) => {
                                format!("Some(crate::to_arrow::<{component}>({accessor}.iter().map(::std::borrow::Cow::Borrowed)))")
                            }
                            (false, true) => {
                                format!(
                                    "crate::to_arrow_opt::<{component}>({accessor}.as_ref().map(|data| [data]))"
                                )
                            }
                            (false, false) => format!("Some(crate::to_arrow::<{component}>([&{accessor}]))"),
                        }
                    })
                    .collect::<Vec<_>>()
                    .join(", ")
            };

            format!(
                r#"
                impl {name} {{
                    pub const REQUIRED_COMPONENTS: [crate::ComponentName; {num_required}] = [{required}];

                    pub const RECOMMENDED_COMPONENTS: [crate::ComponentName; {num_recommended}] = [{recommended}];

                    pub const OPTIONAL_COMPONENTS: [crate::ComponentName; {num_optional}] = [{optional}];

                    pub const ALL_COMPONENTS: [crate::ComponentName; {num_all}] = [{all}];
                }}

                impl crate::Archetype for {name} {{
                    fn name() -> crate::ArchetypeName {{
                        crate::ArchetypeName::Borrowed({fqname:?})
                    }}

                    fn required_components() -> Vec<crate::ComponentName> {{
                        Self::REQUIRED_COMPONENTS.to_vec()
                    }}

                    fn recommended_components() -> Vec<crate::ComponentName> {{
                        Self::RECOMMENDED_COMPONENTS.to_vec()
                    }}

                    fn optional_components() -> Vec<crate::ComponentName> {{
                        Self::OPTIONAL_COMPONENTS.to_vec()
                    }}

                    // TODO: hashmaps

                    #[allow(clippy::unimplemented)]
                    fn to_arrow_datatypes() -> Vec<::arrow2::datatypes::DataType> {{
                        use crate::Component as _;
                        vec![{all_datatypes}]
                    }}

                    fn to_arrow(&self) -> ::re_log_types::DataCellVec {{
                        [{all_serializers}].into_iter().flatten().collect()
                    }}

                    // fn from_arrow(cells: &[&::re_log_types::DataCell]) -> Self
                    // where
                    //     Self: Sized;
                }}
                "#
            )
        }
    }
}

/// Only makes sense for archetypes.
fn quote_builder_from_obj(obj: &Object) -> String {
    assert_eq!(ObjectKind::Archetype, obj.kind);

    let Object {
        filepath: _,
        fqname: _,
        pkg_name: _,
        name,
        docs: _,
        kind: _,
        attrs: _,
        fields,
        specifics: _,
        datatype: _,
    } = obj;

    let required = fields
        .iter()
        .filter(|field| field.required)
        .collect::<Vec<_>>();
    let optional = fields
        .iter()
        .filter(|field| !field.required)
        .collect::<Vec<_>>();

    let mut code = String::new();

    code.push_text(&format!("impl {name} {{"), 1, 0);
    {
        // --- impl new() ---

        let new_params = required
            .iter()
            .map(|field| {
                let (typ, unwrapped) = quote_field_type_from_field(field, true);
                if unwrapped {
                    // This was originally a vec/array!
                    format!(
                        "{}: impl IntoIterator<Item = impl Into<{}>>",
                        field.name, typ
                    )
                } else {
                    format!("{}: impl Into<{}>", field.name, typ)
                }
            })
            .collect::<Vec<_>>()
            .join(", ");
        code.push_text(&format!("pub fn new({new_params}) -> Self {{"), 1, 0);
        {
            code += "Self {\n";
            {
                for field in &required {
                    let (_, unwrapped) = quote_field_type_from_field(field, true);
                    if unwrapped {
                        // This was originally a vec/array!
                        code.push_text(
                            &format!(
                                "{}: {}.into_iter().map(Into::into).collect(),",
                                field.name, field.name
                            ),
                            1,
                            0,
                        );
                    } else {
                        code.push_text(&format!("{}: {}.into(),", field.name, field.name), 1, 0);
                    }
                }
                for field in &optional {
                    code.push_text(&format!("{}: None,", field.name), 1, 0);
                }
            }
            code += "}\n";
        }
        code += "}\n\n";

        // --- impl with_*() ---

        for field in &optional {
            let name = &field.name;
            let (typ, unwrapped) = quote_field_type_from_field(field, true);

            if unwrapped {
                // This was originally a vec/array!
                code.push_text(&format!(
                    "pub fn with_{name}(mut self, {name}: impl IntoIterator<Item = impl Into<{typ}>>) -> Self {{",
                ), 1, 0);
                {
                    code.push_text(
                        &format!(
                            "self.{name} = Some({name}.into_iter().map(Into::into).collect());"
                        ),
                        1,
                        0,
                    );
                    code += "self\n";
                }
            } else {
                code.push_text(
                    &format!("pub fn with_{name}(mut self, {name}: impl Into<{typ}>) -> Self {{",),
                    1,
                    0,
                );
                {
                    code.push_text(&format!("self.{name} = Some({name}.into());"), 1, 0);
                    code += "self\n";
                }
            }

            code += "}\n\n";
        }
    }
    code += "}\n\n";

    code
}

// --- Arrow registry code generators ---

use arrow2::datatypes::{DataType, Field};

// use arrow2::{
//     array::{Array, BooleanArray, FixedSizeListArray, Float32Array, PrimitiveArray},
//     bitmap::Bitmap,
//     buffer::Buffer,
//     datatypes::{DataType, Field},
// };
// use itertools::Itertools as _;

// fn main() {
//     let arr = BooleanArray::new(
//         DataType::Boolean,
//         Bitmap::from_u8_vec(vec![0b00110010], 8),
//         None,
//     );
//     dbg!(arr);

//     let myfloats = [1.0, 2.0, 3.0, 4.0];
//     let array = FixedSizeListArray::new(
//         DataType::FixedSizeList(Box::new(Field::new("item", DataType::Float32, false)), 2),
//         Float32Array::from_vec(myfloats.to_vec()).boxed(),
//         None,
//     );

//     let arrays = array.as_any().downcast_ref::<FixedSizeListArray>().unwrap();
//     let tuples = arrays
//         .values()
//         .as_any()
//         .downcast_ref::<PrimitiveArray<f32>>()
//         .unwrap()
//         .values_iter()
//         .tuples::<(_, _)>();
//     let arrays = dbg!(tuples.collect_vec());
// }

// fn new_float_array(floats: impl Into<Vec<f32>>) -> Box<dyn Array> {
//     Float32Array::new(DataType::Float32, floats.into().into(), None).boxed()
// }

// TODO: so transparency _is_ recursive then?

// TODO: attr.arrow.transparent
// TODO: auto magic to turn self into the right native type (akin to derive_more I guess)
// TODO: optionality and such bs
fn quote_arrow_serializer_from_obj(
    arrow_registry: &ArrowRegistry,
    objects: &Objects,
    obj: &Object,
    xxx: &[String],
) -> String {
    let mut code = String::new();

    // NOTE: always unwrappable since we resolve types much earlier on.
    let datatype = arrow_registry.get(&obj.fqname);
    let datatype = datatype.to_logical_type();

    // TODO: the problem is that rust vs. python vs. arrow transparency are different things
    let is_arrow_transparent = obj.datatype.is_none();
    let is_tuple_struct = is_tuple_struct_from_obj(obj);

    // TODO: for every extension we meet, we need to go down a layer...?

    // TODO: man that gets very nasty once you introduce rust-specific transparency
    // TODO: introduce freaking is_primitive helpers everywhere
    if is_arrow_transparent {
        let field_name = if is_tuple_struct {
            "data0".into()
        } else {
            obj.fields[0].name.clone()
        };

        code.push_unindented_text(
            format!(
                "
                let {field_name}: Vec<_> = data
                    .into_iter()
                    .map(|datum| {{
                        let datum: ::std::borrow::Cow<'a, Self> = datum.into();
                        let Self({field_name}) = datum.into_owned();
                        {field_name}
                    }})
                    .collect();
                "
            ),
            0,
        );

        match &obj.fields[0].typ {
            Type::UInt8
            | Type::UInt16
            | Type::UInt32
            | Type::UInt64
            | Type::Int8
            | Type::Int16
            | Type::Int32
            | Type::Int64
            | Type::Bool
            | Type::Float16
            | Type::Float32
            | Type::Float64
            | Type::String => {
                // TODO: it really is just a dumb field then
                code += &quote_arrow_serializer_from_field(
                    arrow_registry,
                    is_arrow_transparent,
                    is_tuple_struct,
                    &obj.fields[0],
                    xxx,
                    &field_name,
                );
            }
            Type::Array {
                elem_type,
                length: _,
            } => match elem_type {
                ElementType::Object(fqname) => {
                    let obj = objects.get(fqname);
                    let mut yyy = xxx.to_vec();
                    yyy.push(field_name);
                    code += &quote_arrow_serializer_from_obj(arrow_registry, objects, obj, &yyy);
                }
                _ => {
                    code += &quote_arrow_serializer_from_field(
                        arrow_registry,
                        is_arrow_transparent,
                        is_tuple_struct,
                        &obj.fields[0],
                        xxx,
                        &field_name,
                    );
                }
            },
            Type::Object(fqname) => {
                let obj = objects.get(fqname);
                let mut yyy = xxx.to_vec();
                yyy.push(field_name);
                code += &quote_arrow_serializer_from_obj(arrow_registry, objects, obj, &yyy);
            }
            _ => unimplemented!("{:#?}", obj.fields[0].typ),
        }
    } else {
        match datatype {
            DataType::Struct(fields) => {
                let quoted_fields = obj
                    .fields
                    .iter()
                    .map(|field| {
                        quote_arrow_serializer_from_field(
                            arrow_registry,
                            false,
                            false,
                            field,
                            xxx,
                            &field.name,
                        )
                    })
                    .collect::<Vec<_>>()
                    .join(", ");

                let all_obj_fields = obj
                    .fields
                    .iter()
                    .map(|field| field.name.as_str())
                    .collect::<Vec<_>>()
                    .join(", ");
                let all_vec_types = std::iter::repeat("Vec<_>")
                    .take(obj.fields.len())
                    .collect::<Vec<_>>()
                    .join(", ");

                let datatype = quote_arrow_datatype(datatype);

                // TODO: optionality is once again a mess
                code.push_unindented_text(
                    format!(
                        "
                        // TODO: deconstruct the thing
                        let ({all_obj_fields}): ({all_vec_types}) = ::itertools::multiunzip(
                            data
                                .into_iter()
                                .map(|datum| {{
                                    let datum: ::std::borrow::Cow<'a, Self> = datum.into();
                                    let Self {{ {all_obj_fields} }} = datum.into_owned();
                                    ({all_obj_fields})
                                }})
                            );
                        StructArray::new(
                            {datatype},
                            vec![{quoted_fields}],
                            None,
                        ).boxed()
                        "
                    ),
                    0,
                );
            }
            _ => unimplemented!("{datatype:#?}"),
        }
    }

    code
}

fn quote_arrow_serializer_from_field(
    arrow_registry: &ArrowRegistry,
    obj_is_arrow_transparent: bool,
    obj_is_tuple_struct: bool,
    obj_field: &ObjectField,
    xxx: &[String],
    data_var: &str,
) -> String {
    let mut code = String::new();

    // NOTE: always unwrappable since we resolve types much earlier on.
    let datatype = arrow_registry.get(&obj_field.fqname);
    let datatype = datatype.to_logical_type();

    let field_rust_name = if obj_is_tuple_struct {
        "0"
    } else {
        obj_field.name.as_str()
    };
    let field_rust_name = if xxx.is_empty() {
        field_rust_name.to_owned()
    } else {
        [&xxx.join("."), field_rust_name].join(".")
    };
    let (field_rust_type, _) = quote_field_type_from_field(obj_field, true);

    match &datatype {
        DataType::Int8
        | DataType::Int16
        | DataType::Int32
        | DataType::Int64
        | DataType::UInt8
        | DataType::UInt16
        | DataType::UInt32
        | DataType::UInt64
        | DataType::Float16
        | DataType::Float32
        | DataType::Float64 => {
            // TODO: optionalityyyyyyyyyyyyyyyyyyy
            code.push_unindented_text(
                format!(
                    "
                    {{
                    // let data: Vec<{field_rust_type}> =
                    //     {data_var}.into_iter().map(|datum| datum).collect();
                    PrimitiveArray::<{field_rust_type}>::from_vec({data_var}).boxed()
                    }}
                    "
                ),
                0,
            );
        }

        // TODO: deserialize Cows, not Strings
        DataType::Utf8 => {
            let quoted_map = if obj_field.required {
                format!(".map(|datum| Some(datum))")
            } else {
                format!(".map(|datum| datum)")
            };

            // TODO: don't go through from
            // TODO: new_unchecked
            code.push_unindented_text(
                format!(
                    "
                    {{
                    let data: Vec<_> = {data_var}.into_iter() {quoted_map} .collect();
                    Utf8Array::<i32>::from(data).boxed()
                    }}
                    "
                ),
                0,
            );
        }

        DataType::FixedSizeList(inner, _length) => {
            let inner_datatype = inner.data_type().to_logical_type();

            // TODO
            match inner_datatype.to_physical_type() {
                arrow2::datatypes::PhysicalType::Primitive(_) => {}
                _ => unimplemented!("{inner_datatype:#?}"),
            }

            let inner_datatype = quote_arrow_datatype(inner_datatype);
            let inner_arrow_type = inner_datatype.trim_start_matches("DataType::");

            // NOTE: Makes sense because we don't have Rust-specific transparency.
            // TODO: this can only work if the transparency target is itself a scalar
            // TODO: this can only work if the transparency target is itself a tuple struct
            let quoted_flatmap = if obj_is_arrow_transparent {
                // format!(".flat_map(|datum| datum.{field_rust_name}.0)")
                format!(".flat_map(|datum| datum)")
            } else {
                format!(".flat_map(|datum| datum)")
            };

            let datatype = quote_arrow_datatype(&datatype);
            // let quoted = quote_arrow_field(&Field {
            //     name: "item".into(),
            //     data_type: datatype.clone(),
            //     is_nullable: !obj_field.required,
            //     metadata: Default::default(),
            // });

            // TODO: obviously this doesn't handle non-scalar element types as is
            code.push_unindented_text(
                format!(
                    "
                    {{
                    let data: Vec<_> = {data_var}.into_iter() {quoted_flatmap} .collect();
                    FixedSizeListArray::new(
                        {datatype},
                        {inner_arrow_type}Array::from_vec(data).boxed(),
                        None,
                    ).boxed()
                    }}
                    "
                ),
                0,
            );
        }

        _ => unimplemented!("{datatype:#?}"), // NOLINT
    }

    code
}

// TODO: The rust object _has_ to be the driver, always. The Arrow type merely follows along and
// throws an error if it cannot.
// ...UPDATE: or not -_-

fn quote_arrow_deserializer_from_obj(
    arrow_registry: &ArrowRegistry,
    objects: &Objects,
    obj: &Object,
    xxx: &[String],
) -> String {
    let mut code = String::new();

    // NOTE: always unwrappable since we resolve types much earlier on.
    let datatype = arrow_registry.get(&obj.fqname);
    let datatype = datatype.to_logical_type();

    // TODO: the problem is that rust vs. python vs. arrow transparency are different things
    let is_arrow_transparent = obj.datatype.is_none();
    let is_tuple_struct = is_tuple_struct_from_obj(obj);

    // TODO: for every extension we meet, we need to go down a layer...?

    // TODO: man that gets very nasty once you introduce rust-specific transparency
    // TODO: introduce freaking is_primitive helpers everywhere
    if is_arrow_transparent {
        let field_name = if is_tuple_struct {
            "data0".into()
        } else {
            obj.fields[0].name.clone()
        };

        let quoted_data = match &obj.fields[0].typ {
            Type::UInt8
            | Type::UInt16
            | Type::UInt32
            | Type::UInt64
            | Type::Int8
            | Type::Int16
            | Type::Int32
            | Type::Int64
            | Type::Bool
            | Type::Float16
            | Type::Float32
            | Type::Float64
            | Type::String => {
                // TODO: it really is just a dumb field then
                quote_arrow_deserializer_from_field(
                    arrow_registry,
                    is_arrow_transparent,
                    is_tuple_struct,
                    &obj.fields[0],
                    xxx,
                    &field_name,
                )
            }
            Type::Array {
                elem_type,
                length: _,
            } => match elem_type {
                ElementType::Object(fqname) => {
                    let obj = objects.get(fqname);
                    let mut yyy = xxx.to_vec();
                    yyy.push(field_name.clone());
                    quote_arrow_deserializer_from_obj(arrow_registry, objects, obj, &yyy)
                }
                _ => quote_arrow_deserializer_from_field(
                    arrow_registry,
                    is_arrow_transparent,
                    is_tuple_struct,
                    &obj.fields[0],
                    xxx,
                    &field_name,
                ),
            },
            Type::Object(fqname) => {
                let obj = objects.get(fqname);
                let mut yyy = xxx.to_vec();
                yyy.push(field_name.clone());
                quote_arrow_deserializer_from_obj(arrow_registry, objects, obj, &yyy)
            }
            _ => unimplemented!("{:#?}", obj.fields[0].typ),
        };

        if is_tuple_struct {
            code.push_unindented_text(
                format!("{quoted_data}.map(|datum| Self(datum)).collect()"),
                0,
            );
        } else {
            code.push_unindented_text(
                format!("{quoted_data}.map(|datum| Self {{ {field_name}: datum }}).collect()"),
                0,
            );
        };
    } else {
        match datatype {
            DataType::Struct(fields) => {
                code.push_unindented_text(
                    format!(
                        "
                        // TODO: unwrapping is in fact _not_ safe: nothing is ever safe when
                        // deserializing anyhow.
                        let array = cell
                            .as_arrow_ref()
                            .as_any()
                            .downcast_ref::<::arrow2::array::StructArray>()
                            .unwrap();

                        "
                    ),
                    0,
                );

                for obj_field in &obj.fields {
                    let quoted = quote_arrow_deserializer_from_field(
                        arrow_registry,
                        false,
                        false,
                        obj_field,
                        xxx,
                        &obj_field.name,
                    );
                    let obj_field_name = &obj_field.name;
                    code.push_unindented_text(format!("let {obj_field_name} = {quoted};"), 1);
                }

                let all_obj_field_names = obj
                    .fields
                    .iter()
                    .map(|field| field.name.as_str())
                    .collect::<Vec<_>>()
                    .join(", ");

                // TODO: optional bs
                // TODO: only clone if primitive types...
                // TODO: optionality is once again a mess
                // `cell` should probably be passed in as a param eh...
                code.push_unindented_text(
                    format!(
                        "

                        #[allow(clippy::clone_on_copy)]
                         ::itertools::izip!({all_obj_field_names})
                             .map(|({all_obj_field_names})| Self {{
                                 x: x.clone(),
                                 y: y.clone(),
                             }})
                             .collect()
                        "
                    ),
                    0,
                );
            }
            _ => unimplemented!("{datatype:#?}"),
        }
    }

    code
}

fn quote_arrow_deserializer_from_field(
    arrow_registry: &ArrowRegistry,
    obj_is_arrow_transparent: bool,
    obj_is_tuple_struct: bool,
    obj_field: &ObjectField,
    xxx: &[String],
    data_var: &str,
) -> String {
    let mut code = String::new();

    // NOTE: always unwrappable since we resolve types much earlier on.
    let datatype = arrow_registry.get(&obj_field.fqname);
    let datatype = datatype.to_logical_type();

    let field_rust_name = if obj_is_tuple_struct {
        "0"
    } else {
        obj_field.name.as_str()
    };
    let field_rust_name = if xxx.is_empty() {
        field_rust_name.to_owned()
    } else {
        [&xxx.join("."), field_rust_name].join(".")
    };
    let (field_rust_type, _) = quote_field_type_from_field(obj_field, true);

    // TODO: well the object type clearly isn't driving here??
    match &datatype {
        DataType::Int8
        | DataType::Int16
        | DataType::Int32
        | DataType::Int64
        | DataType::UInt8
        | DataType::UInt16
        | DataType::UInt32
        | DataType::UInt64
        | DataType::Float16
        | DataType::Float32
        | DataType::Float64 => {
            // TODO: optionalityyyyyyyyyyyyyyyyyyy
            code.push_unindented_text(
                format!(
                    "
                    cell.as_arrow_ref()
                        .as_any()
                        // TODO: this one can certainly fail though
                        .downcast_ref::<PrimitiveArray<{field_rust_type}>>()
                        .unwrap()
                        .values_iter()
                        .copied()
                    "
                ),
                0,
            );
        }

        DataType::Utf8 => {
            // TODO: optionalityyyyyyyyyyyyyyyyyyy
            // TODO: don't actually deserialize a string
            code.push_unindented_text(
                format!(
                    "
                    cell.as_arrow_ref()
                        .as_any()
                        // TODO: this one can certainly fail though
                        .downcast_ref::<Utf8Array<i32>>()
                        .unwrap()
                        .values_iter()
                        // TODO: there is no good reason to alloc+copy, just use a raw buf<u8>
                        .map(ToString::to_string)
                    "
                ),
                0,
            );
        }

        DataType::FixedSizeList(inner, length) => {
            // TODO: tuple size depends on length
            // TODO: optionality
            let quoted_chunks = (0..*length)
                .map(|i| format!("chunk[{i}]"))
                .collect::<Vec<_>>()
                .join(", ");
            code.push_unindented_text(
                format!(
                    "
                    {{
                    // NOTE: unwrapping cannot fail, we've just checked the type!
                    let data = cell
                        .as_arrow_ref()
                        .as_any()
                        .downcast_ref::<FixedSizeListArray>()
                        .unwrap();
                    let data = data
                        .values()
                        .as_any()
                        // TODO: this one can certainly fail though
                        .downcast_ref::<PrimitiveArray<{field_rust_type}>>()
                        .unwrap()
                        .values();

                    data.chunks_exact({length}).map(|chunk| [ {quoted_chunks} ])
                    }}
                    "
                ),
                0,
            );
        }

        _ => unimplemented!("{datatype:#?}"), // NOLINT
    }

    code
}

fn quote_arrow_deserializer_from_obj_legacy(
    arrow_registry: &ArrowRegistry,
    obj: &Object,
) -> String {
    let mut code = String::new();

    // NOTE: always unwrappable since we resolve types much earlier on.
    let datatype = arrow_registry.get(&obj.fqname);
    let datatype = datatype.to_logical_type();

    let is_transparent = obj.datatype.is_none();
    if is_transparent {
        // NOTE: Arrow-transparent object must have a single field.
        let obj_field = &obj.fields[0];
        // NOTE: we do not support Arrow transparency at the field level, thus this must be unwrappable.
        let datatype = arrow_registry.get(&obj_field.fqname);
        match &datatype {
            DataType::FixedSizeList(inner, length) => {
                let inner_datatype = quote_arrow_datatype(&inner.data_type);
                let arrow_type = inner_datatype.trim_start_matches("DataType::");
                let (rust_type, _) = quote_field_type_from_field(obj_field, true);
                let rust_name = is_transparent
                    .then_some(obj_field.name.as_str())
                    .unwrap_or("0");

                // TODO: tuple size depends on length
                // TODO: optionality
                let name = &obj.name;
                code.push_unindented_text(
                    format!(
                        "
                        let data = data.as_any().downcast_ref::<FixedSizeListArray>().unwrap();
                        let data = data
                            .values()
                            .as_any()
                            .downcast_ref::<PrimitiveArray<{rust_type}>>()
                            .unwrap()
                            .values();

                        data.chunks_exact(2).map(|chunk| {name}([chunk[0], chunk[1]])).collect()
                        "
                    ),
                    0,
                );
            }
            _ => unimplemented!("{datatype:#?}"), // NOLINT
        }
    } else {
        match &datatype {
            _ => unimplemented!("{datatype:#?}"), // NOLINT
        }
    }

    code
}

// fn quote_arrow_serializer_from_field(
//     arrow_registry: &ArrowRegistry,
//     field: &ObjectField,
// ) -> String {
//     // NOTE: we do not support Arrow transparency at the field level, this must be unwrappable.
//     let datatype = field.datatype.as_ref().unwrap();
//     match &datatype {
//         DataType::FixedSizeList(field, length) => {
//             // let mypoints = [[1.0, 2.0], [3.0, 4.0]];
//             // let mypoints = mypoints.into_iter().flatten().collect::<Vec<_>>();
//             // let arr = FixedSizeListArray::new(
//             //     DataType::FixedSizeList(Box::new(Field::new("item", DataType::Float32, false)), 2), //
//             //     Float32Array::from_vec(mypoints).boxed(),
//             //     None,
//             // );

//             is_tuple_struct_from_obj(obj);
//             dbg!(&obj.fields[0]);

//             // let data: Vec<f32> = self.into();
//             // let field = quote_arrow_field(field);
//             // format!("DataType::FixedSizeList(Box::new({field}), {length})")
//             unimplemented!("{datatype:#?}")
//         }
//         _ => unimplemented!("{datatype:#?}"), // NOLINT
//     }
// }

fn quote_arrow_datatype(datatype: &DataType) -> String {
    match datatype {
        DataType::Null => "DataType::Null".to_owned(),
        DataType::Boolean => "DataType::Boolean".to_owned(),
        DataType::Int8 => "DataType::Int8".to_owned(),
        DataType::Int16 => "DataType::Int16".to_owned(),
        DataType::Int32 => "DataType::Int32".to_owned(),
        DataType::Int64 => "DataType::Int64".to_owned(),
        DataType::UInt8 => "DataType::UInt8".to_owned(),
        DataType::UInt16 => "DataType::UInt16".to_owned(),
        DataType::UInt32 => "DataType::UInt32".to_owned(),
        DataType::UInt64 => "DataType::UInt64".to_owned(),
        DataType::Float16 => "DataType::Float16".to_owned(),
        DataType::Float32 => "DataType::Float32".to_owned(),
        DataType::Float64 => "DataType::Float64".to_owned(),
        DataType::Date32 => "DataType::Date32".to_owned(),
        DataType::Date64 => "DataType::Date64".to_owned(),
        DataType::Binary => "DataType::Binary".to_owned(),
        DataType::LargeBinary => "DataType::LargeBinary".to_owned(),
        DataType::Utf8 => "DataType::Utf8".to_owned(),
        DataType::LargeUtf8 => "DataType::LargeUtf8".to_owned(),
        DataType::FixedSizeList(field, length) => {
            let field = quote_arrow_field(field);
            format!("DataType::FixedSizeList(Box::new({field}), {length})")
        }
        DataType::Union(fields, _, mode) => {
            let fields = fields
                .iter()
                .map(quote_arrow_field)
                .collect::<Vec<_>>()
                .join(", ");

            // NOTE: unindenting to work around a rustfmt bug
            unindent::unindent(&format!(
                r#"
                DataType::Union(
                    vec![{fields}],
                    None,
                    UnionMode::{mode:?},
                )
                "#
            ))
        }
        DataType::Struct(fields) => {
            let fields = fields
                .iter()
                .map(quote_arrow_field)
                .collect::<Vec<_>>()
                .join(", ");

            format!("DataType::Struct(vec![{fields}])")
        }
        DataType::Extension(name, datatype, metadata) => {
            let datatype = quote_arrow_datatype(datatype);
            let metadata = quote_optional_string(metadata.as_deref());

            // NOTE: unindenting to work around a rustfmt bug
            unindent::unindent(&format!(
                r#"
                DataType::Extension(
                    "{name}".to_owned(),
                    Box::new({datatype}),
                    {metadata},
                )
                "#
            ))
        }
        _ => unimplemented!("{datatype:#?}"), // NOLINT
    }
}

fn quote_arrow_field(field: &Field) -> String {
    let Field {
        name,
        data_type,
        is_nullable,
        metadata,
    } = field;

    let datatype = quote_arrow_datatype(data_type);
    let metadata = quote_metadata_map(metadata);

    // NOTE: unindenting to work around a rustfmt bug
    unindent::unindent(&format!(
        r#"
        Field {{
            name: "{name}".to_owned(),
            data_type: {datatype},
            is_nullable: {is_nullable},
            metadata: {metadata},
        }}
        "#
    ))
}

fn quote_optional_string(s: Option<&str>) -> String {
    if let Some(s) = s {
        format!("Some({s:?})")
    } else {
        "None".into()
    }
}

fn quote_metadata_map(metadata: &BTreeMap<String, String>) -> String {
    let kvs = metadata
        .iter()
        .map(|(k, v)| format!("({k:?}, {v:?})"))
        .collect::<Vec<_>>()
        .join(", ");
    format!("[{kvs}].into()")
}

// --- Helpers ---

fn iter_archetype_components<'a>(
    obj: &'a Object,
    requirement_attr_value: &'static str,
) -> impl Iterator<Item = String> + 'a {
    assert_eq!(ObjectKind::Archetype, obj.kind);
    obj.fields.iter().filter_map(move |field| {
        field
            .try_get_attr::<String>(requirement_attr_value)
            .map(|_| match &field.typ {
                Type::Object(fqname) => fqname.clone(),
                Type::Vector { elem_type } => match elem_type {
                    ElementType::Object(fqname) => fqname.clone(),
                    _ => {
                        panic!("archetype field must be an object/union or an array/vector of such")
                    }
                },
                _ => panic!("archetype field must be an object/union or an array/vector of such"),
            })
    })
}
