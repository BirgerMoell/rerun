// TODO: all you need to dump the store as log messages

use itertools::Itertools as _;
use re_log_types::{
    external::arrow2_convert::deserialize::{arrow_array_deserialize_iterator, TryIntoCollection},
    msg_bundle::{wrap_in_listarray, Component, ComponentBundle, MsgBundle},
    MsgId, TimePoint,
};

use crate::DataStore;

// ---

impl DataStore {
    // TODO
    pub fn as_msg_bundles(&self) -> impl Iterator<Item = MsgBundle> + '_ {
        // TODO: should we just kmerge everything?

        let msg_bundles = self.timeless_indices.values().map(|index| {
            //     pub msg_id: MsgId,
            //     pub components: Vec<ComponentBundle>,

            //     pub entity_path: EntityPath,
            let ent_path = index.ent_path.clone();

            //     pub time_point: TimePoint,
            let timepoint = TimePoint::timeless();

            // TODO: could compact at this point
            // TODO: that's once we support batching tho

            let all_indices = index
                .indices
                .iter()
                // TODO: MsgId should be defined by the caller
                // .filter(|(component, _)| {
                //     ![MsgId::name(), DataStore::insert_id_key()].contains(component)
                // })
                .filter(|(component, _)| ![DataStore::insert_id_key()].contains(component))
                .collect_vec();

            let msg_ids_index = &index.indices[&MsgId::name()]; // TODO
            let msg_ids_table = &self.timeless_components[&MsgId::name()]; // TODO
            let mut msg_ids = msg_ids_index
                .iter()
                .map(|row_idx| row_idx.map(|row_idx| msg_ids_table.get(row_idx)));

            // TODO: not so much indices at this point...
            let mut indices = Vec::with_capacity(all_indices.len());
            for (i, (component, index)) in all_indices.iter().enumerate() {
                let table = &self.timeless_components[*component]; // TODO
                indices.push((
                    *component,
                    index
                        .iter()
                        .map(|row_idx| row_idx.map(|row_idx| table.get(row_idx))),
                ));
            }

            let mut msg_bundles = Vec::with_capacity(index.num_rows as _);

            // TODO: shouldnt embed autogenerated keys.. we know it's an autogenerated one if its
            // row index can be found in the cluster_comp_cache

            for i in 0..index.num_rows as usize {
                // TODO
                let msg_id = msg_ids.next().flatten().unwrap();
                // TODO: deserializing this doesn't make much sense
                // NOTE: Reminder that we don't _really_ support splats, so a row with N instances
                // will actually have N message IDs.
                let msg_id: Vec<MsgId> = TryIntoCollection::try_into_collection(msg_id).unwrap();

                let components = indices
                    .iter_mut()
                    .filter_map(|(component, index)| {
                        index
                            .next()
                            .flatten()
                            .map(|data| (**component, wrap_in_listarray(data)))
                    })
                    .map(|(component, data)| ComponentBundle::new(component, data))
                    .collect_vec();

                msg_bundles.push(MsgBundle {
                    msg_id: msg_id[0],
                    entity_path: ent_path.clone(),
                    time_point: timepoint.clone(),
                    components,
                });
            }

            msg_bundles // TODO
        });

        msg_bundles.kmerge_by(|bundle1, bundle2| bundle1.msg_id < bundle2.msg_id)
    }
}
